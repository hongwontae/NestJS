1. 레파지토리 의존성 사용하기
1-1. constructor(@InjectRepository(UsersEntity) private repo : Repository<UsersEntity>){}
    1. repo : Repository<UsersEntity>를 통해서 repo에 타입을 설정합니다.
    2. @InjectRepository(UsersEntity)를 통해서 DI 컨테이너에 엔티티에 해당하는 Repository 객체를 생성
        + 생성된 Repository를 repo 변수에 주입합니다.


2. 레파지토리 메서드
2-1. create()
=> 엔티티 인스턴스를 생성합니다.

2-2. save()
=> 일반 객체나 엔티티 인스턴스를 받아서 DB에 저장합니다.

2-3. find 관련 메서드
    1. find() : 모든 행을 조회, 항상 배열을 반환합니다. 아무것도 없다면 []
    2. findOne() : 조건에 맞는 하나의 행을 조회, 없으면 null 
    (객체를 받아서 where를 사용하여 조건을 넣습니다. findOne({where : {id : 1}}))
    3. findOneBy() : 인자에 조건 객체를 그대로 받습니다. findOneBY({id : 1})
    4. findBy() : 조건에 맞는 여러 행을 조회합니다.

2-4. update 방법
    1. update 메서드를 사용하면 엔티티 인스턴스가 생성되지 않아서 디버깅이 힘듭니다.
    2. find 관련 메서드를 통해 update 대상 row를 찾고 인스턴스를 생성합니다.
    3. 해당 인스턴스 속성 값을 변경합니다.
    4. save를 통해 저장합니다.

2-5. remove(entity)
    1. 엔티티 객체를 받아서 삭제합니다.
    2. 이벤트 후크가 실행되기에 디버깅에 용이합니다.

2-6. delete()
    1. 조건이나 id를 받아서 바로 삭제합니다.
    2. 후크가 적용되지 않아 디버기이 힘듭니다.


3. Entity에서 사용 가능한 메서드
3-1. @AfterInsert()
=> 데이터베이스에 데이터가 삽입될 떄마다 데코가 적용된 함수가 실행됩니다.

3-2. @AfterUpdate()
=> 데이터베이스에 데이터가 업데이트 때마다 데코가 적용된 함수가 실행됩니다.

3-3. @AfterRemove()
=> 데이터베이스에 데이터가 삭제될 떄마다 데코가 적용된 함수가 실행됩니다.
** create로 엔티티 인스턴스를 만들고 save를 호출해야 위 3개의 후크가 실행됩니다. **


4. Object.assign(target(object), source, source..);
=> 주소를 유지한 채 속성을 추가하는 함수입니다.


6. TS에서 클래스는 타입 레벨에서는 객체 타입으로 취급됩니다.
=> 컴파일 시점에서 클래스는 {id : string; name : string} 같이 타입 역할도 합니다.

7. TS에서 객체타입[] 문법도 가능합니다.

8. TS in
=> 유니온을 순회하며 객체 형태로 확장하는 문법입니다.

9. type Partial<T> = {
    [P in keyof T]? : T[P]
}
9-1. keyof T를 통해 키 값을 유니온 형태로 변환합니다.
9-2. in은 유니온을 받아서 객체 타입 형태로 확장합니다.
9-3. 이 떄 키에 해당되는 값은 T[P] 입니다.
9-4. 그리고 ?에 의해서 키가 없어도 되고 있어도 됩니다. 즉, 생략해도 된다는 의미입니다.


10. http 관련 에러 notFoundException이 서비스에서 던져졌다면 해당 모듈 컨트롤러에게
    전달되어 응답으로 전달됩니다. 이 떄 다른 모듈이 해당 서비스를 사용하고 http 관련 컨트롤러가 아닌
    webSocket 같은 것일 떄 notFoundException 같은 에러를 이해하지 못합니다.

=> 가장 좋은 방법은 service에서 에러를 던지는게 아니라 컨트롤러에서 에러를 던지는 것이 제일 좋습니다.
        
