** 설치한 nestjs 라이브러리를 살펴보려면 d.ts -> 상단 바 우클릭 -> reveal in explorer view **
** 생성자 매개변수는 클래스 내부의 멤버 변수가 될 수 없습니다. **
** 생성자 매개변수에 접근 제한자를 붙이면 자동으로 멤버 속성으로 등록해주는 기능이 있습니다. **

** 제어 역전 + 의존성 주입으로 얻을 수 있는 가장 큰 장점은 테스트가 용이하다는 점입니다. **

1. Servie & Repository
=> 서비스는 비지니스 논리, 레파지토리는 데이터 관련 논리를 정의합니다.
=> 둘 다 클래스로 정의합니다.


2. 에러 객체
2-1. @nestjs/common에서 여러 에러 객체를 찾을 수 있습니다.
2-2. throw new 에러 객체() 형태로 에러 던져 응답을 줄 수 있습니다.


3. 제어 역전
3-1. 재사용 가능한 코드를 빌드하거나 작성을 용이하게 하는 소프트웨어 엔지니어링 개념입니다.
3-2. 클래스 자체가 인스턴스를 생성하지 않도록 작성해야 합니다.

3-3. 사용방법
    1. 서비스, 레파지토리가 존재할 떄,
    2. 의존성이 필요할 떄 생성자 매개변수에 (public messagesRepo : MessagesRepository)를 추가합니다.

    3. 그 다음 클래스에 @Injectable() 데코레이터를 추가합니다. 
    (해당 클래스는 DI 컨테이너가 관리할 자격이 있다고 알립니다. 즉, 의존성 주입의 후보로 인식됩니다. 아직 DI에 등록 x)

    4. @Module의 providers에 DI 컨테이너에 등록될 클래스를 나열합니다.
    => 해당 클래스들을 DI 컨테이너 관리하게 만듭니다.

3-4. 3-3은 사실 타입 정보만 받은 것입니다. 실제 인스턴스는 DI 컨테이너가 생성하여 주입해줍니다.
 이 떄 생성된 인스턴스는 재활용됩니다.


4. NestJS 의존성 주입 Detail
4-1. @Injectable, Module 속성에 providers 두 개의 작업 완료된 클래스들은
 DI 컨테이너에 의해 해당 클래스의 인스턴스가 생성됩니다. 
4-2. 또한 해당 인스턴스는 싱글톤입니다. (하나만 사용한다.)
4-3. 생성자 함수로 의존성을 가져오면 DI 컨테이너가 알아서 주입해줍니다.


