1. 비밀번호 해시
    1-1. 해시 함수
    => password, password1의 인자를 받은 해시 함수의 결과값은 크게 달라집니다.
    => 역으로 계산할 수 없습니다.

    1-2. 비밀번호 해시 검증
    => DB에는 해시된 password 값이 존재합니다.
    => Service에서 DB 해시 password 값을 가져옵니다.
    => 로그인을 위해 password가 들어오면 마찬가지로 해시화합니다.
    => 위 두 개를 비교해서 일치하면 통과시킵니다.

    1-3. 비밀번호 해시 검증 +
    => salt 이름을 가진 임의 문자열을 패스워드와 결합해 DB에 저장하고 이 값을 검증하는 방법입니다.
    => 가입 시 password + salt를 합쳐서 해시화합니다.
    => 저장 할 떄 해시값과 salt를 같이 저장합니다. 이 떄 해시값과 salt를 분리할 수 있는 구분자가 필요합니다.
    => 로그인 시 DB에 저장된 password 값을 불러옵니다.
    => password에서 구분자를 통해 해시값과 salt를 분리합니다.
    => 로그인 할 떄 비밀번호 + 가져온 salt를 합쳐 해시값을 생성합니다.
    => 일치하면 로그인 성공


2. NestJS 비밀번호 해시화
2-1. 


3. cookie-session
3-1. 서버는 로그인 정보를 DB에 저장하지 않고 암호화된 세션 객체를 클라이언트 쿠키에 넣어서 로그인 상태를 유지
=> 이를 위해서 사용하는 라이브러리입니다.
3-2. session을 응답하고 또 다시 응답할 떄 session 값이 변경되지 않았다면 Set-Cookie을 전송하지 않습니다.
=> dirty checking이라고 합니다.
3-3. 브라우저에서 요청을 보낼 떄 항상 쿠키는 포함되어 보내집니다.
=> 그리고 이 배후에 Set-Cookie 값을 나갈 떄는 암호화, 들어올 떄는 복호화가 실행됩니다. (cookie-session에 의해서)
3-4. 3-3 이 후 컨트롤러는 session에 접근하여 서비스에 값을 보낼 수 있습니다. (이 떄 원래의 값으로 돌아옵니다.)



4. Custom Decorator
4-1. import {createParamDecorator, ExecutionContext} from '@nestjs/common';
4-2. exprot const DecoratorName = createParamDecorator(
    (data : any, context : ExecutionContext)=>{
        return 
    }
) => 해당 return 문이 값으로 전달됩니다.
4-5. data는 @DecoName() -> 인자값에 해당됩니다.
4-4. ExecutionContext는 요청 객체, Websocket... 다양하게 사용될 수 있습니다.



=> 인터셉터는 의존성을 받아서 사용할 수 있습니다.
=> 데코레이터는 의존성을 받아서 사용할 수 없습니다.
=> 요청이 들어오기 전 인터셉터가 의존성을 이용해 데이터를 조작하고 decorator가 이를 사용할 수 있습니다.
=> 둘 다 context.switchToHttp().getRequest()가 존재하기 떄문입니다.