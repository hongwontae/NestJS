1. 비밀번호 해시
    1-1. 해시 함수
    => password, password1의 인자를 받은 해시 함수의 결과값은 크게 달라집니다.
    => 역으로 계산할 수 없습니다.

    1-2. 비밀번호 해시 검증
    => DB에는 해시된 password 값이 존재합니다.
    => Service에서 DB 해시 password 값을 가져옵니다.
    => 로그인을 위해 password가 들어오면 마찬가지로 해시화합니다.
    => 위 두 개를 비교해서 일치하면 통과시킵니다.

    1-3. 비밀번호 해시 검증 +
    => salt 이름을 가진 임의 문자열을 패스워드와 결합해 DB에 저장하고 이 값을 검증하는 방법입니다.
    => 가입 시 password + salt를 합쳐서 해시화합니다.
    => 저장 할 떄 해시값과 salt를 같이 저장합니다. 이 떄 해시값과 salt를 분리할 수 있는 구분자가 필요합니다.
    => 로그인 시 DB에 저장된 password 값을 불러옵니다.
    => password에서 구분자를 통해 해시값과 salt를 분리합니다.
    => 로그인 할 떄 비밀번호 + 가져온 salt를 합쳐 해시값을 생성합니다.
    => 일치하면 로그인 성공


2. cookie-session
2-1. 서버는 로그인 정보를 DB에 저장하지 않고 암호화된 세션 객체를 클라이언트 쿠키에 넣어서 로그인 상태를 유지
=> 이를 위해서 사용하는 라이브러리입니다.
2-2. session을 응답하고 또 다시 응답할 떄 session 값이 변경되지 않았다면 Set-Cookie을 전송하지 않습니다.
=> dirty checking이라고 합니다.
2-3. 브라우저에서 요청을 보낼 떄 항상 쿠키는 포함되어 보내집니다.
=> 그리고 이 배후에 Set-Cookie 값을 나갈 떄는 암호화, 들어올 떄는 복호화가 실행됩니다. (cookie-session에 의해서)
2-4. 2-3 이 후 컨트롤러는 session에 접근하여 서비스에 값을 보낼 수 있습니다. (이 떄 원래의 값으로 돌아옵니다.)



4. Custom Decorator
4-1. import {createParamDecorator, ExecutionContext} from '@nestjs/common';
4-2. exprot const DecoratorName = createParamDecorator(
    (data : any, context : ExecutionContext)=>{
        return 
    }
) => 해당 return 문이 값으로 전달됩니다.
4-5. data는 @DecoName() -> 인자값에 해당됩니다.
4-4. ExecutionContext는 요청 객체, Websocket... 다양하게 사용될 수 있습니다.



=> 인터셉터는 의존성을 받아서 사용할 수 있습니다.
=> 데코레이터는 의존성을 받아서 사용할 수 없습니다.
=> 요청이 들어오기 전 인터셉터가 의존성을 이용해 데이터를 조작하고 decorator가 이를 사용할 수 있습니다.
=> 둘 다 context.switchToHttp().getRequest()가 존재하기 떄문입니다.


5. 전역적인 인터셉터
5-1. 인터셉터를 사용하는 모듈에서 import {APP_INTERCEPTOR} from '@nestjs/core'를 가져옵니다.
5-2. providers : [
    {
        provide : APP_INTERCEPTOR,
        useClass : CustomInterceptor
    }
]
=> 5-2 작업으로 이제 모든 컨트롤러는 CustomeInterceptor를 거쳐야 합니다.


6. Guard
6-1. 요청을 받을 자격이 있는지를 판단하는 NestJS 도구입니다.
6-2. 내부에서 true를 반환하면 통과/ false를 반환하면 요청 차단합니다.
6-3. 요청을 수정하지 않습니다. (통과 여부만 확인 가능)

6-4. Custom Guard 생성 방법
    1. import {CanActivate, ExecutionContext} from '@nestjs/common';
    2. export class CustomGuard implements CanActivate {
        canActivate(context : ExecutionContext){
            // return truthy면 통과 falsy면 불통 합니다.
        }
    }

6-5. Guard 적용 방법
    1. controller에서 useGuards 데코와 커스텀 가드를 가져옵니다.
    2. 사용할 컨트롤러 혹은 라우트 핸들러 위에 UseGuards(customGuard) 작업을 하면 됩니다.